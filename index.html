<!DOCTYPE html>
<html>
<head>
    <title>Micro Evolution</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <style>
        body { margin: 0; overflow: hidden; touch-action: none; background: #1a1a1a; }
        #gameCanvas { position: absolute; }
        .ui {
            position: fixed; padding: 10px; background: #00000055; border-radius: 5px; 
            color: white; font-family: Arial; backdrop-filter: blur(3px);
        }
        #stats { top: 10px; left: 10px; }
        #abilities { bottom: 10px; right: 10px; text-align: right; }
        button { background: #444; color: white; border: none; padding: 12px; margin: 4px; 
                border-radius: 5px; touch-action: manipulation; }
        #menu { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); 
               text-align: center; background: #000000aa; padding: 20px; border-radius: 10px; }
        #gameOver { display: none; }
        .joystick {
            position: fixed; bottom: 30px; left: 30px; width: 100px; height: 100px;
            background: #ffffff22; border-radius: 50%; touch-action: none; display: none;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <div class="joystick" id="joystick"></div>
    <div id="stats" class="ui" style="display: none;">
        <div>Health: <span id="health">100</span></div>
        <div>Energy: <span id="energy">50</span></div>
        <div>DNA: <span id="dna">0</span> (Lvl <span id="level">1</span>)</div>
    </div>
    <div id="abilities" class="ui" style="display: none;">
        <button onclick="evolve('speed')">üöÄ Speed (10 DNA)</button>
        <button onclick="evolve('health')">‚ù§Ô∏è Health (15 DNA)</button>
        <button onclick="evolve('vision')">üëÅÔ∏è Vision (20 DNA)</button>
    </div>

    <div id="menu" class="ui">
        <h1>Micro Evolution</h1>
        <button onclick="startNewGame()">New Game</button>
        <button onclick="continueGame()" id="continueBtn">Continue</button>
    </div>

    <div id="gameOver" class="ui">
        <h2>Game Over!</h2>
        <button onclick="showMenu()">Back to Menu</button>
    </div>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const WORLD_SIZE = 3000;
let cameraX = 0, cameraY = 0;
let gameState = 'menu';
let animationFrameId;
let touchId = null;

function noise(x, y) {
    return Math.abs(Math.sin(x * 12.9898 + y * 78.233) * 43758.5453 % 1;
}

function generateBiome(x, y) {
    const value = noise(x/500, y/500);
    if(value > 0.9) return 'toxic';
    if(value > 0.7) return 'rocky';
    if(value > 0.4) return 'grassland';
    return 'water';
}

function resizeCanvas() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
}
resizeCanvas();
window.addEventListener('resize', resizeCanvas);

let player = {
    x: WORLD_SIZE/2, y: WORLD_SIZE/2, size: 20,
    speed: 2, health: 100, energy: 50, dna: 0,
    vision: 200, direction: 0, level: 1, xp: 0,
    color: '#ffffff'
};

let world = {
    resources: [],
    creatures: [],
    particles: []
};

function createCreature(type, x, y, level=1) {
    const mutations = {
        speed: 1 + (level-1)*0.1,
        health: 1 + (level-1)*0.2,
        attack: 1 + (level-1)*0.15
    };
    
    const base = {
        x, y, size: 15, health: 100 * mutations.health,
        direction: 0, speed: 1.5 * mutations.speed,
        attack: 0, lastAttack: 0, cooldown: false,
        level, mutations, color: '#ffffff'
    };
    
    switch(type) {
        case 'predator':
            base.color = '#ff4444';
            base.speed = 1.6 * mutations.speed;
            base.attack = 5 * mutations.attack;
            base.vision = 300;
            base.attackCooldown = 3000;
            break;
        case 'herbivore':
            base.color = '#44ff44';
            base.speed = 1.7 * mutations.speed;
            base.flee = true;
            base.herd = [];
            break;
        case 'parasite':
            base.color = '#aa44ff';
            base.size = 10;
            base.speed = 1.5 * mutations.speed;
            base.drain = 2 * mutations.attack;
            break;
    }
    return base;
}

function generateWorld() {
    world.resources = [];
    world.creatures = [];
    
    // –†–µ—Å—É—Ä—Å—ã
    for(let x = 0; x < WORLD_SIZE; x += 100) {
        for(let y = 0; y < WORLD_SIZE; y += 100) {
            const biome = generateBiome(x, y);
            const count = biome === 'grassland' ? 5 : 2;
            
            for(let i = 0; i < count; i++) {
                world.resources.push({
                    x: x + Math.random()*100,
                    y: y + Math.random()*100,
                    type: biome === 'toxic' ? 'dna' : 
                         biome === 'rocky' ? 'mineral' : 'food',
                    value: 10,
                    anim: Math.random() * Math.PI * 2
                });
            }
        }
    }
    
    // –°—É—â–µ—Å—Ç–≤–∞
    for(let i = 0; i < 30; i++) {
        const type = ['predator', 'herbivore', 'parasite'][Math.floor(Math.random()*3)];
        const level = Math.random() > 0.9 ? 2 : 1;
        const creature = createCreature(type, 
            Math.random() * WORLD_SIZE,
            Math.random() * WORLD_SIZE,
            level
        );
        world.creatures.push(creature);
    }
}

function updateCreatures() {
    world.creatures.forEach((creature) => {
        if(creature.health <= 0) return;

        // AI
        let target = null;
        if(creature.attack) {
            if(!creature.cooldown && distance(creature, player) < creature.vision) {
                target = player;
            }
        } else if(creature.flee) {
            const predator = world.creatures.find(c => c.attack && distance(c, creature) < 200);
            target = predator || (creature.herd?.length ? creature.herd[0] : null);
        }

        // –î–≤–∏–∂–µ–Ω–∏–µ
        const angle = target ? 
            Math.atan2(target.y - creature.y, target.x - creature.x) : 
            creature.direction + (Math.random()-0.5)*0.3;
        
        creature.direction = angle;
        creature.x += Math.cos(angle) * creature.speed;
        creature.y += Math.sin(angle) * creature.speed;

        // –ì—Ä–∞–Ω–∏—Ü—ã
        creature.x = Math.max(0, Math.min(WORLD_SIZE, creature.x));
        creature.y = Math.max(0, Math.min(WORLD_SIZE, creature.y));

        // –ê—Ç–∞–∫–∞
        if(creature.attack && Date.now() - creature.lastAttack > creature.attackCooldown) {
            if(distance(creature, player) < creature.size + player.size) {
                player.health -= creature.attack;
                creature.lastAttack = Date.now();
                creature.cooldown = true;
                setTimeout(() => creature.cooldown = false, 1500);
                createParticles(player.x, player.y, 10, '#ff0000');
            }
        }

        // –†–∞–∑–º–Ω–æ–∂–µ–Ω–∏–µ
        if(creature.health > 120 + creature.level*20 && Math.random() < 0.001) {
            creature.health -= 50;
            const newLevel = creature.level + (Math.random() < 0.2 ? 1 : 0);
            world.creatures.push(createCreature(
                creature.attack ? 'predator' : creature.flee ? 'herbivore' : 'parasite',
                creature.x + Math.random()*40 -20,
                creature.y + Math.random()*40 -20,
                newLevel
            ));
        }
    });

    // –£–¥–∞–ª–µ–Ω–∏–µ –º–µ—Ä—Ç–≤—ã—Ö —Å—É—â–µ—Å—Ç–≤
    world.creatures = world.creatures.filter(c => c.health > 0);
}

function createParticles(x, y, count, color) {
    for(let i = 0; i < count; i++) {
        world.particles.push({
            x, y,
            vx: (Math.random()-0.5)*4,
            vy: (Math.random()-0.5)*4,
            life: 1,
            color,
            size: Math.random()*3 + 2
        });
    }
}

function update() {
    if(gameState !== 'playing') return;
    
    // –î–≤–∏–∂–µ–Ω–∏–µ –∏–≥—Ä–æ–∫–∞
    const speed = player.speed * (player.energy > 0 ? 1 : 0.8);
    if(targetX !== null && targetY !== null) {
        const dx = targetX - player.x;
        const dy = targetY - player.y;
        const dist = Math.sqrt(dx*dx + dy*dy);
        
        if(dist > speed) {
            player.x += (dx/dist)*speed;
            player.y += (dy/dist)*speed;
            player.direction = Math.atan2(dy, dx);
            player.energy = Math.max(0, player.energy - 0.05);
        }
    }
    
    cameraX = player.x - canvas.width/2;
    cameraY = player.y - canvas.height/2;

    // –°–±–æ—Ä —Ä–µ—Å—É—Ä—Å–æ–≤
    world.resources = world.resources.filter(resource => {
        resource.anim += 0.05;
        if(distance(resource, player) < player.size) {
            createParticles(resource.x, resource.y, 8, 
                resource.type === 'food' ? '#88ff88' :
                resource.type === 'mineral' ? '#8888ff' : '#ff88ff');
            
            player[resource.type === 'food' ? 'health' : 'dna'] += 
                resource.type === 'food' ? 5 : 1;
            
            player.xp += 1;
            if(player.xp > player.level * 10) {
                player.level++;
                player.xp = 0;
                player.health += 20;
                createParticles(player.x, player.y, 20, '#ffffff');
            }
            
            return false;
        }
        return true;
    });

    updateCreatures();
    
    // –ß–∞—Å—Ç–∏—Ü—ã
    world.particles.forEach(p => {
        p.x += p.vx;
        p.y += p.vy;
        p.life -= 0.015;
        p.vy += 0.1;
    });
    world.particles = world.particles.filter(p => p.life > 0);

    // UI
    document.getElementById('health').textContent = Math.round(player.health);
    document.getElementById('energy').textContent = Math.round(player.energy);
    document.getElementById('dna').textContent = player.dna;
    document.getElementById('level').textContent = player.level;

    if(player.health <= 0) gameOver();

    animationFrameId = requestAnimationFrame(update);
    draw();
}

function draw() {
    ctx.fillStyle = '#1a1a1a';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // –†–µ—Å—É—Ä—Å—ã
    world.resources.forEach(resource => {
        ctx.save();
        ctx.translate(resource.x - cameraX, resource.y - cameraY);
        ctx.rotate(resource.anim);
        ctx.fillStyle = resource.type === 'food' ? '#88ff8855' :
                        resource.type === 'mineral' ? '#8888ff55' : '#ff88ff55';
        ctx.fillRect(-6, -6, 12, 12);
        ctx.restore();
    });

    // –°—É—â–µ—Å—Ç–≤–∞
    world.creatures.forEach(creature => {
        const screenX = creature.x - cameraX;
        const screenY = creature.y - cameraY;
        
        // –¢–µ–ª–æ
        ctx.fillStyle = creature.color;
        ctx.beginPath();
        ctx.arc(screenX, screenY, creature.size, 0, Math.PI*2);
        ctx.fill();

        // –ì–ª–∞–∑–∞
        const eyeDist = creature.size * 0.4;
        const eyeAngle = creature.direction;
        [Math.PI/6, -Math.PI/6].forEach(offset => {
            ctx.fillStyle = '#ffffff';
            ctx.beginPath();
            ctx.arc(
                screenX + Math.cos(eyeAngle + offset) * eyeDist,
                screenY + Math.sin(eyeAngle + offset) * eyeDist,
                creature.size * 0.15, 0, Math.PI*2
            );
            ctx.fill();
        });

        // –£—Ä–æ–≤–µ–Ω—å
        if(creature.level > 1) {
            ctx.fillStyle = '#fff';
            ctx.font = '12px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('Lv'+creature.level, screenX, screenY - creature.size - 5);
        }
    });

    // –ò–≥—Ä–æ–∫
    const playerScreenX = player.x - cameraX;
    const playerScreenY = player.y - cameraY;
    ctx.fillStyle = player.color;
    ctx.beginPath();
    ctx.arc(playerScreenX, playerScreenY, player.size, 0, Math.PI*2);
    ctx.fill();
    
    // –ì–ª–∞–∑–∞ –∏–≥—Ä–æ–∫–∞
    [Math.PI/6, -Math.PI/6].forEach(offset => {
        ctx.fillStyle = '#ffffff';
        ctx.beginPath();
        ctx.arc(
            playerScreenX + Math.cos(player.direction + offset) * player.size * 0.4,
            playerScreenY + Math.sin(player.direction + offset) * player.size * 0.4,
            player.size * 0.15, 0, Math.PI*2
        );
        ctx.fill();
    });

    // –ß–∞—Å—Ç–∏—Ü—ã
    world.particles.forEach(p => {
        ctx.fillStyle = p.color;
        ctx.globalAlpha = p.life;
        ctx.beginPath();
        ctx.arc(p.x - cameraX, p.y - cameraY, p.size * p.life, 0, Math.PI*2);
        ctx.fill();
    });
    ctx.globalAlpha = 1;
}

function distance(a, b) {
    return Math.sqrt((a.x - b.x)**2 + (a.y - b.y)**2);
}

// –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ
let targetX = null, targetY = null;

canvas.addEventListener('click', e => {
    const rect = canvas.getBoundingClientRect();
    targetX = e.clientX - rect.left + cameraX;
    targetY = e.clientY - rect.top + cameraY;
});

canvas.addEventListener('touchstart', e => {
    e.preventDefault();
    const rect = canvas.getBoundingClientRect();
    const touch = e.touches[0];
    targetX = touch.clientX - rect.left + cameraX;
    targetY = touch.clientY - rect.top + cameraY;
});

// –≠–≤–æ–ª—é—Ü–∏—è
function evolve(type) {
    const upgrades = {
        speed: { cost: 10, effect: p => p.speed += 0.5 },
        health: { cost: 15, effect: p => { p.health += 30; p.health = Math.min(200, p.health) }},
        vision: { cost: 20, effect: p => p.vision += 50 }
    };
    
    if(upgrades[type] && player.dna >= upgrades[type].cost) {
        upgrades[type].effect(player);
        player.dna -= upgrades[type].cost;
        createParticles(player.x, player.y, 10, '#ffff00');
    }
}

// –ú–µ–Ω—é
function startNewGame() {
    gameState = 'playing';
    document.getElementById('menu').style.display = 'none';
    document.getElementById('stats').style.display = 'block';
    document.getElementById('abilities').style.display = 'block';
    player = {
        x: WORLD_SIZE/2, y: WORLD_SIZE/2, size: 20,
        speed: 2, health: 100, energy: 50, dna: 0,
        vision: 200, direction: 0, level: 1, xp: 0,
        color: '#ffffff'
    };
    generateWorld();
    update();
}

function continueGame() {
    const saved = localStorage.getItem('gameState');
    if(saved) {
        const state = JSON.parse(saved);
        Object.assign(player, state.player);
        Object.assign(world, state.world);
        gameState = 'playing';
        document.getElementById('menu').style.display = 'none';
        document.getElementById('stats').style.display = 'block';
        document.getElementById('abilities').style.display = 'block';
        update();
    }
}

function gameOver() {
    gameState = 'gameOver';
    cancelAnimationFrame(animationFrameId);
    document.getElementById('stats').style.display = 'none';
    document.getElementById('abilities').style.display = 'none';
    document.getElementById('gameOver').style.display = 'block';
}

function showMenu() {
    gameState = 'menu';
    document.getElementById('menu').style.display = 'block';
    document.getElementById('gameOver').style.display = 'none';
    document.getElementById('continueBtn').style.display = 
        localStorage.getItem('gameState') ? 'inline-block' : 'none';
}

// –ê–≤—Ç–æ—Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ
setInterval(() => {
    if(gameState === 'playing') {
        localStorage.setItem('gameState', JSON.stringify({
            player,
            world
        }));
    }
}, 3000);

// –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è
showMenu();
window.Telegram.WebApp.ready();
</script>
</body>
</html>