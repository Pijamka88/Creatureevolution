<!DOCTYPE html>
<html>
<head>
    <title>Evolution Master</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <style>
        body { margin: 0; overflow: hidden; touch-action: none; background: #1a1a1a; }
        #gameCanvas { position: absolute; }
        .ui {
            position: fixed; padding: 10px; background: #00000055; border-radius: 5px; 
            color: white; font-family: Arial; backdrop-filter: blur(3px);
        }
        #stats { top: 10px; left: 10px; }
        #abilities { bottom: 10px; right: 10px; text-align: right; }
        button { background: #444; color: white; border: none; padding: 8px; margin: 2px; border-radius: 3px; }
        #menu { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center; }
        .joystick { position: fixed; bottom: 30px; left: 30px; width: 100px; height: 100px; }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <div class="joystick" id="joystick"></div>
    <!-- Остальные UI элементы -->

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const WORLD_SIZE = 3000;
const BIOME_SIZE = 600;
let cameraX = 0, cameraY = 0;

// Генерация процедурного мира
function generatePerlin(seed) {
    // Реализация шума Перлина
}

// Система уровней
class EvolutionSystem {
    constructor() {
        this.level = 1;
        this.xp = 0;
        this.mutations = [];
    }
    
    addXP(amount) {
        this.xp += amount;
        if(this.xp > this.level * 100) {
            this.level++;
            player.dna += this.level * 2;
        }
    }
}

// Модифицированный класс существа
class Creature {
    constructor(type, x, y, mutations = []) {
        // Базовая конфигурация
        this.applyMutations(mutations);
    }
    
    applyMutations(mutations) {
        mutations.forEach(m => {
            this[m.stat] += m.value;
        });
    }
    
    reproduce() {
        const mutations = [];
        if(Math.random() < 0.3) {
            mutations.push({
                stat: ['speed', 'health', 'vision'][Math.floor(Math.random()*3)],
                value: Math.random() * 0.5 - 0.25
            });
        }
        return new Creature(this.type, this.x, this.y, mutations);
    }
}

// Визуальные эффекты для еды
class FoodParticle {
    constructor(x, y, type) {
        this.angle = Math.random() * Math.PI*2;
        this.scale = 0.5 + Math.random();
    }
    
    update() {
        this.angle += 0.1;
        this.scale = 0.5 + Math.sin(Date.now()/200) * 0.3;
    }
}

// Оптимизированное управление для iPhone
class TouchController {
    constructor() {
        this.touchStart = null;
        this.activeTouch = null;
        this.init();
    }
    
    init() {
        canvas.addEventListener('touchstart', e => {
            const rect = canvas.getBoundingClientRect();
            this.touchStart = {
                x: e.touches[0].clientX - rect.left,
                y: e.touches[0].clientY - rect.top,
                time: Date.now()
            };
            this.activeTouch = e.touches[0].identifier;
        });
        
        canvas.addEventListener('touchmove', e => {
            for(let touch of e.changedTouches) {
                if(touch.identifier === this.activeTouch) {
                    const rect = canvas.getBoundingClientRect();
                    targetX = touch.clientX - rect.left;
                    targetY = touch.clientY - rect.top;
                }
            }
        });
    }
}

// Модифицированная логика хищников
class PredatorAI {
    constructor(creature) {
        this.creature = creature;
        this.attackCooldown = 3000;
    }
    
    update() {
        if(Date.now() - this.creature.lastAttack > this.attackCooldown) {
            // Логика атаки
        }
    }
}

// Инициализация основных систем
const evolutionSystem = new EvolutionSystem();
new TouchController();

// Остальной код игры с интеграцией новых систем...

// Процедурная генерация мира
function generateProceduralWorld() {
    const noise = generatePerlin(Date.now());
    for(let x = 0; x < WORLD_SIZE; x += BIOME_SIZE) {
        for(let y = 0; y < WORLD_SIZE; y += BIOME_SIZE) {
            const biomeValue = noise(x/WORLD_SIZE, y/WORLD_SIZE);
            // Генерация различных биомов
        }
    }
}

// Модифицированная функция отрисовки глаз
function drawEyes(ctx, creature) {
    const eyePositions = [
        { offset: Math.PI/6, size: creature.size * 0.15 },
        { offset: -Math.PI/6, size: creature.size * 0.15 }
    ];
    
    eyePositions.forEach(pos => {
        ctx.beginPath();
        ctx.arc(
            Math.cos(creature.direction + pos.offset) * creature.size * 0.4,
            Math.sin(creature.direction + pos.offset) * creature.size * 0.4,
            pos.size, 0, Math.PI*2
        );
        ctx.fillStyle = '#fff';
        ctx.fill();
        
        // Зрачок
        ctx.beginPath();
        ctx.arc(
            Math.cos(creature.direction) * pos.size/2,
            Math.sin(creature.direction) * pos.size/2,
            pos.size/2, 0, Math.PI*2
        );
        ctx.fillStyle = '#000';
        ctx.fill();
    });
}

// Оптимизированный игровой цикл
function optimizedGameLoop() {
    // Реализация requestAnimationFrame с контролем FPS
}

// Интеграция всех систем
function fullIntegration() {
    generateProceduralWorld();
    // Инициализация остальных компонентов
}

// Запуск игры
fullIntegration();
</script>
</body>
</html>