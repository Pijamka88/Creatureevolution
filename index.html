<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>CreatureEvolution</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: #000;
            color: #fff;
            font-family: Arial, sans-serif;
            overflow: hidden;
            touch-action: none;
        }
        
        #gameCanvas {
            display: block;
            background: #000;
            border: 2px solid #333;
        }
        
        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 10;
            font-size: 14px;
        }
        
        #upgradePanel {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid #fff;
            padding: 20px;
            display: none;
            z-index: 20;
        }
        
        .upgrade-btn {
            display: block;
            margin: 10px 0;
            padding: 10px 20px;
            background: #333;
            color: #fff;
            border: 1px solid #666;
            cursor: pointer;
            font-size: 14px;
        }
        
        .upgrade-btn:hover {
            background: #555;
        }
        
        #controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
        }
        
        .control-btn {
            width: 50px;
            height: 50px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            color: #fff;
            font-size: 18px;
            cursor: pointer;
            touch-action: manipulation;
        }
        
        .control-btn:active {
            background: rgba(255, 255, 255, 0.3);
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    
    <div id="ui">
        <div>Level: <span id="level">1</span></div>
        <div>XP: <span id="xp">0</span>/<span id="xpToNext">10</span></div>
        <div>Size: <span id="size">10</span></div>
        <div>Speed: <span id="speed">2</span></div>
    </div>
    
    <div id="upgradePanel">
        <h3>Level Up! Choose an upgrade:</h3>
        <button class="upgrade-btn" onclick="selectUpgrade('size')">Increase Size (+20%)</button>
        <button class="upgrade-btn" onclick="selectUpgrade('speed')">Increase Speed (+15%)</button>
        <button class="upgrade-btn" onclick="selectUpgrade('vision')">Increase Vision (+30%)</button>
        <button class="upgrade-btn" onclick="selectUpgrade('efficiency')">Better Digestion (+25%)</button>
    </div>
    
    <div id="controls">
        <button class="control-btn" id="upBtn">↑</button>
        <button class="control-btn" id="downBtn">↓</button>
        <button class="control-btn" id="leftBtn">←</button>
        <button class="control-btn" id="rightBtn">→</button>
    </div>

    <script>
        // Game configuration
        const CONFIG = {
            WORLD_WIDTH: 2000,
            WORLD_HEIGHT: 2000,
            VIEWPORT_WIDTH: window.innerWidth,
            VIEWPORT_HEIGHT: window.innerHeight,
            FOOD_COUNT: 200,
            CREATURE_COUNT: 15,
            FOOD_SPAWN_RATE: 0.3,
            CREATURE_SPAWN_RATE: 0.05
        };

        // Game variables
        let canvas, ctx;
        let camera = { x: 0, y: 0 };
        let player;
        let creatures = [];
        let food = [];
        let gameRunning = true;
        let keys = {};

        // Creature types
        const CREATURE_TYPES = {
            PLAYER: { color: '#00ff00', ai: false },
            PREDATOR: { color: '#ff0000', ai: 'aggressive' },
            HERBIVORE: { color: '#ffff00', ai: 'passive' },
            PARASITE: { color: '#ff00ff', ai: 'sneaky' }
        };

        // Food types
        const FOOD_TYPES = [
            { color: '#00aa00', value: 1, size: 3 },
            { color: '#0066aa', value: 2, size: 4 },
            { color: '#aa6600', value: 3, size: 5 }
        ];

        class Creature {
            constructor(x, y, type = 'PLAYER') {
                this.x = x;
                this.y = y;
                this.type = type;
                this.color = CREATURE_TYPES[type].color;
                this.size = 10;
                this.level = 1;
                this.xp = 0;
                this.xpToNext = 10;
                this.speed = 2;
                this.vision = 100;
                this.efficiency = 1;
                this.vx = 0;
                this.vy = 0;
                this.target = null;
                this.aiTimer = 0;
                this.health = 100;
                this.maxHealth = 100;
            }

            update() {
                if (this.type !== 'PLAYER') {
                    this.updateAI();
                }

                // Apply movement
                this.x += this.vx;
                this.y += this.vy;

                // World boundaries
                this.x = Math.max(this.size, Math.min(CONFIG.WORLD_WIDTH - this.size, this.x));
                this.y = Math.max(this.size, Math.min(CONFIG.WORLD_HEIGHT - this.size, this.y));

                // Friction
                this.vx *= 0.95;
                this.vy *= 0.95;
            }

            updateAI() {
                this.aiTimer++;
                
                if (this.aiTimer % 30 === 0) { // Update AI every 30 frames
                    this.findTarget();
                }

                if (this.target) {
                    this.moveTowardsTarget();
                }
            }

            findTarget() {
                let bestTarget = null;
                let bestDistance = Infinity;

                if (this.type === 'PREDATOR') {
                    // Hunt smaller creatures
                    creatures.forEach(creature => {
                        if (creature !== this && creature.size < this.size * 0.8) {
                            const dist = this.distanceTo(creature);
                            if (dist < this.vision && dist < bestDistance) {
                                bestTarget = creature;
                                bestDistance = dist;
                            }
                        }
                    });
                } else if (this.type === 'HERBIVORE') {
                    // Find food, avoid predators
                    food.forEach(f => {
                        const dist = this.distanceTo(f);
                        if (dist < this.vision && dist < bestDistance) {
                            bestTarget = f;
                            bestDistance = dist;
                        }
                    });

                    // Check for nearby predators
                    creatures.forEach(creature => {
                        if (creature.type === 'PREDATOR' && creature.size > this.size * 0.8) {
                            const dist = this.distanceTo(creature);
                            if (dist < this.vision * 0.7) {
                                // Run away from predator
                                const angle = Math.atan2(this.y - creature.y, this.x - creature.x);
                                this.vx += Math.cos(angle) * this.speed * 0.5;
                                this.vy += Math.sin(angle) * this.speed * 0.5;
                                return;
                            }
                        }
                    });
                } else if (this.type === 'PARASITE') {
                    // Follow larger creatures to steal their food
                    creatures.forEach(creature => {
                        if (creature !== this && creature.size > this.size) {
                            const dist = this.distanceTo(creature);
                            if (dist < this.vision && dist < bestDistance) {
                                bestTarget = creature;
                                bestDistance = dist;
                            }
                        }
                    });
                }

                this.target = bestTarget;
            }

            moveTowardsTarget() {
                if (!this.target) return;

                const dx = this.target.x - this.x;
                const dy = this.target.y - this.y;
                const distance = Math.sqrt(dx * dx + dy * dy);

                if (distance > 0) {
                    const moveSpeed = this.type === 'PARASITE' ? this.speed * 0.7 : this.speed;
                    this.vx += (dx / distance) * moveSpeed * 0.1;
                    this.vy += (dy / distance) * moveSpeed * 0.1;
                }
            }

            distanceTo(other) {
                const dx = this.x - other.x;
                const dy = this.y - other.y;
                return Math.sqrt(dx * dx + dy * dy);
            }

            move(dx, dy) {
                this.vx += dx * this.speed * 0.2;
                this.vy += dy * this.speed * 0.2;
            }

            eat(foodItem) {
                const xpGain = Math.floor(foodItem.value * this.efficiency);
                this.xp += xpGain;
                
                if (this.xp >= this.xpToNext) {
                    this.levelUp();
                }
                
                // Grow slightly
                this.size += 0.5;
                this.updateUI();
            }

            levelUp() {
                this.level++;
                this.xp = 0;
                this.xpToNext = Math.floor(this.xpToNext * 1.5);
                
                if (this.type === 'PLAYER') {
                    this.showUpgradePanel();
                } else {
                    // AI auto-upgrade
                    this.autoUpgrade();
                }
            }

            autoUpgrade() {
                const upgrades = ['size', 'speed', 'vision', 'efficiency'];
                const randomUpgrade = upgrades[Math.floor(Math.random() * upgrades.length)];
                this.applyUpgrade(randomUpgrade);
            }

            applyUpgrade(type) {
                switch(type) {
                    case 'size':
                        this.size *= 1.2;
                        this.maxHealth *= 1.1;
                        this.health = this.maxHealth;
                        break;
                    case 'speed':
                        this.speed *= 1.15;
                        break;
                    case 'vision':
                        this.vision *= 1.3;
                        break;
                    case 'efficiency':
                        this.efficiency *= 1.25;
                        break;
                }
                this.updateUI();
            }

            showUpgradePanel() {
                document.getElementById('upgradePanel').style.display = 'block';
                gameRunning = false;
            }

            updateUI() {
                if (this.type === 'PLAYER') {
                    document.getElementById('level').textContent = this.level;
                    document.getElementById('xp').textContent = this.xp;
                    document.getElementById('xpToNext').textContent = this.xpToNext;
                    document.getElementById('size').textContent = Math.floor(this.size);
                    document.getElementById('speed').textContent = this.speed.toFixed(1);
                }
            }

            draw() {
                const screenX = this.x - camera.x;
                const screenY = this.y - camera.y;
                
                // Draw creature
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(screenX, screenY, this.size, 0, Math.PI * 2);
                ctx.fill();
                
                // Draw outline
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 1;
                ctx.stroke();
                
                // Draw level for player
                if (this.type === 'PLAYER') {
                    ctx.fillStyle = '#fff';
                    ctx.font = '12px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(this.level, screenX, screenY + 4);
                }
            }
        }

        class Food {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                const type = FOOD_TYPES[Math.floor(Math.random() * FOOD_TYPES.length)];
                this.color = type.color;
                this.value = type.value;
                this.size = type.size;
            }

            draw() {
                const screenX = this.x - camera.x;
                const screenY = this.y - camera.y;
                
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(screenX, screenY, this.size, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        function init() {
            canvas = document.getElementById('gameCanvas');
            ctx = canvas.getContext('2d');
            
            // Set canvas size
            canvas.width = CONFIG.VIEWPORT_WIDTH;
            canvas.height = CONFIG.VIEWPORT_HEIGHT;
            
            // Create player
            player = new Creature(CONFIG.WORLD_WIDTH / 2, CONFIG.WORLD_HEIGHT / 2, 'PLAYER');
            creatures.push(player);
            
            // Create other creatures
            for (let i = 0; i < CONFIG.CREATURE_COUNT; i++) {
                const types = ['PREDATOR', 'HERBIVORE', 'PARASITE'];
                const type = types[Math.floor(Math.random() * types.length)];
                const x = Math.random() * CONFIG.WORLD_WIDTH;
                const y = Math.random() * CONFIG.WORLD_HEIGHT;
                
                // Ensure creatures spawn far from each other
                let validPosition = false;
                let attempts = 0;
                while (!validPosition && attempts < 50) {
                    validPosition = true;
                    for (let creature of creatures) {
                        if (Math.sqrt((x - creature.x) ** 2 + (y - creature.y) ** 2) < 150) {
                            validPosition = false;
                            break;
                        }
                    }
                    attempts++;
                }
                
                if (validPosition) {
                    creatures.push(new Creature(x, y, type));
                }
            }
            
            // Create initial food
            for (let i = 0; i < CONFIG.FOOD_COUNT; i++) {
                spawnFood();
            }
            
            setupControls();
            gameLoop();
        }

        function spawnFood() {
            const x = Math.random() * CONFIG.WORLD_WIDTH;
            const y = Math.random() * CONFIG.WORLD_HEIGHT;
            food.push(new Food(x, y));
        }

        function spawnCreature() {
            const types = ['PREDATOR', 'HERBIVORE', 'PARASITE'];
            const type = types[Math.floor(Math.random() * types.length)];
            const x = Math.random() * CONFIG.WORLD_WIDTH;
            const y = Math.random() * CONFIG.WORLD_HEIGHT;
            creatures.push(new Creature(x, y, type));
        }

        function setupControls() {
            // Keyboard controls
            document.addEventListener('keydown', (e) => {
                keys[e.key] = true;
            });
            
            document.addEventListener('keyup', (e) => {
                keys[e.key] = false;
            });
            
            // Touch controls
            document.getElementById('upBtn').addEventListener('touchstart', () => keys['ArrowUp'] = true);
            document.getElementById('upBtn').addEventListener('touchend', () => keys['ArrowUp'] = false);
            document.getElementById('downBtn').addEventListener('touchstart', () => keys['ArrowDown'] = true);
            document.getElementById('downBtn').addEventListener('touchend', () => keys['ArrowDown'] = false);
            document.getElementById('leftBtn').addEventListener('touchstart', () => keys['ArrowLeft'] = true);
            document.getElementById('leftBtn').addEventListener('touchend', () => keys['ArrowLeft'] = false);
            document.getElementById('rightBtn').addEventListener('touchstart', () => keys['ArrowRight'] = true);
            document.getElementById('rightBtn').addEventListener('touchend', () => keys['ArrowRight'] = false);
            
            // Prevent context menu on long press
            document.addEventListener('contextmenu', (e) => e.preventDefault());
        }

        function handleInput() {
            if (!gameRunning) return;
            
            if (keys['ArrowUp'] || keys['w'] || keys['W']) {
                player.move(0, -1);
            }
            if (keys['ArrowDown'] || keys['s'] || keys['S']) {
                player.move(0, 1);
            }
            if (keys['ArrowLeft'] || keys['a'] || keys['A']) {
                player.move(-1, 0);
            }
            if (keys['ArrowRight'] || keys['d'] || keys['D']) {
                player.move(1, 0);
            }
        }

        function update() {
            if (!gameRunning) return;
            
            handleInput();
            
            // Update creatures
            creatures.forEach(creature => creature.update());
            
            // Check food consumption
            food = food.filter(f => {
                for (let creature of creatures) {
                    if (creature.distanceTo(f) < creature.size + f.size) {
                        creature.eat(f);
                        return false;
                    }
                }
                return true;
            });
            
            // Check creature interactions
            for (let i = 0; i < creatures.length; i++) {
                for (let j = i + 1; j < creatures.length; j++) {
                    const c1 = creatures[i];
                    const c2 = creatures[j];
                    const distance = c1.distanceTo(c2);
                    
                    if (distance < c1.size + c2.size) {
                        // Collision detected
                        if (c1.size > c2.size * 1.2) {
                            // c1 eats c2
                            if (c1.type === 'PREDATOR' || (c1.type === 'PLAYER' && c2.type !== 'PLAYER')) {
                                c1.eat({ value: Math.floor(c2.size / 2), size: c2.size });
                                creatures.splice(j, 1);
                                j--;
                            }
                        } else if (c2.size > c1.size * 1.2) {
                            // c2 eats c1
                            if (c2.type === 'PREDATOR' || (c2.type === 'PLAYER' && c1.type !== 'PLAYER')) {
                                c2.eat({ value: Math.floor(c1.size / 2), size: c1.size });
                                creatures.splice(i, 1);
                                i--;
                                break;
                            }
                        }
                    }
                }
            }
            
            // Spawn new food and creatures occasionally
            if (Math.random() < CONFIG.FOOD_SPAWN_RATE / 60 && food.length < CONFIG.FOOD_COUNT * 2) {
                spawnFood();
            }
            
            if (Math.random() < CONFIG.CREATURE_SPAWN_RATE / 60 && creatures.length < CONFIG.CREATURE_COUNT * 2) {
                spawnCreature();
            }
            
            // Update camera to follow player
            camera.x = player.x - CONFIG.VIEWPORT_WIDTH / 2;
            camera.y = player.y - CONFIG.VIEWPORT_HEIGHT / 2;
            
            // Keep camera within world bounds
            camera.x = Math.max(0, Math.min(CONFIG.WORLD_WIDTH - CONFIG.VIEWPORT_WIDTH, camera.x));
            camera.y = Math.max(0, Math.min(CONFIG.WORLD_HEIGHT - CONFIG.VIEWPORT_HEIGHT, camera.y));
        }

        function draw() {
            // Clear canvas
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw world border
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 2;
            ctx.strokeRect(-camera.x, -camera.y, CONFIG.WORLD_WIDTH, CONFIG.WORLD_HEIGHT);
            
            // Draw grid (Petri dish pattern)
            ctx.strokeStyle = '#111';
            ctx.lineWidth = 1;
            const gridSize = 50;
            for (let x = -camera.x % gridSize; x < canvas.width; x += gridSize) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }
            for (let y = -camera.y % gridSize; y < canvas.height; y += gridSize) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }
            
            // Draw food
            food.forEach(f => {
                if (f.x > camera.x - 50 && f.x < camera.x + CONFIG.VIEWPORT_WIDTH + 50 &&
                    f.y > camera.y - 50 && f.y < camera.y + CONFIG.VIEWPORT_HEIGHT + 50) {
                    f.draw();
                }
            });
            
            // Draw creatures
            creatures.forEach(creature => {
                if (creature.x > camera.x - 50 && creature.x < camera.x + CONFIG.VIEWPORT_WIDTH + 50 &&
                    creature.y > camera.y - 50 && creature.y < camera.y + CONFIG.VIEWPORT_HEIGHT + 50) {
                    creature.draw();
                }
            });
        }

        function gameLoop() {
            update();
            draw();
            requestAnimationFrame(gameLoop);
        }

        function selectUpgrade(type) {
            player.applyUpgrade(type);
            document.getElementById('upgradePanel').style.display = 'none';
            gameRunning = true;
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            CONFIG.VIEWPORT_WIDTH = window.innerWidth;
            CONFIG.VIEWPORT_HEIGHT = window.innerHeight;
            canvas.width = CONFIG.VIEWPORT_WIDTH;
            canvas.height = CONFIG.VIEWPORT_HEIGHT;
        });

        // Initialize game when page loads
        window.addEventListener('load', init);
    </script>
</body>
</html>