<!DOCTYPE html>
<html>
<head>
    <title>Microbe Evolution 2.0</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <style>
        body { margin: 0; overflow: hidden; touch-action: none; background: #1a1a1a; }
        #gameCanvas { position: absolute; }
        .ui {
            position: fixed; padding: 10px; background: #00000055; border-radius: 5px; 
            color: white; font-family: Arial; backdrop-filter: blur(3px);
        }
        #stats { top: 10px; left: 10px; }
        #abilities { bottom: 10px; right: 10px; text-align: right; }
        button { background: #444; color: white; border: none; padding: 8px; margin: 2px; border-radius: 3px; }
        #menu { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center; }
        #joystick { position: fixed; bottom: 50px; left: 50px; width: 100px; height: 100px; opacity: 0.7; }
        .level-bar { position: fixed; top: 10px; right: 10px; width: 200px; height: 20px; background: #333; }
        .level-progress { height: 100%; background: #4CAF50; transition: width 0.3s; }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <div id="joystick"></div>
    <div class="level-bar"><div class="level-progress" style="width: 0%"></div></div>
    <!-- Остальные UI элементы как в предыдущей версии -->

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const WORLD_SIZE = 2000;
let cameraX = 0, cameraY = 0;
let gameState = 'menu';
let animationFrameId;

// Настройки управления для iPhone
let touchId = null;
const JOYSTICK_RADIUS = 40;
let joystickVector = { x: 0, y: 0 };

// Система уровней
let playerLevel = 1;
let levelProgress = 0;

// Настройка canvas
function resizeCanvas() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
}
resizeCanvas();
window.addEventListener('resize', resizeCanvas);

// Игровые объекты
let player = {
    x: WORLD_SIZE/2, y: WORLD_SIZE/2, size: 20,
    speed: 2, health: 100, energy: 50, dna: 0,
    vision: 200, direction: 0,
    mutations: [],
    level: 1
};

let world = {
    resources: [],
    creatures: [],
    particles: []
};

// Новые визуальные эффекты для еды
function createFoodEffect(x, y) {
    for(let i = 0; i < 8; i++) {
        world.particles.push({
            x, y,
            vx: (Math.random()-0.5)*3,
            vy: (Math.random()-0.5)*3,
            life: 1,
            color: '#00ff00',
            size: Math.random()*3 + 2
        });
    }
}

// Система мутаций
const mutations = [
    { name: 'Двойная скорость', chance: 0.1, apply: c => c.speed *= 2 },
    { name: 'Гигантизм', chance: 0.05, apply: c => c.size *= 1.5 },
    { name: 'Регенерация', chance: 0.2, apply: c => c.healthRegen = 1 }
];

function applyMutations(creature) {
    mutations.forEach(m => {
        if(Math.random() < m.chance) {
            m.apply(creature);
        }
    });
}

// Генерация существ с мутациями
function createCreature(type, x, y) {
    const base = {
        x, y, size: 15, health: 100,
        direction: 0, speed: 1.5,
        attack: 0, lastAttack: 0,
        cooldown: false
    };
    
    let creature;
    switch(type) {
        case 'predator':
            creature = {...base, 
                color: '#ff4444', 
                speed: 1.8,
                attack: 5,
                vision: 300,
                attackCooldown: 3000 // Увеличенное время восстановления
            };
            break;
        // Остальные типы существ
    }
    
    applyMutations(creature);
    return creature;
}

// Обновленная система уровней
function updateLevelSystem() {
    const neededDNA = playerLevel * 25;
    if(player.dna >= neededDNA) {
        player.dna -= neededDNA;
        playerLevel++;
        levelProgress = 0;
        document.querySelector('.level-progress').style.width = '0%';
        player.health = 100;
        player.speed += 0.2;
    } else {
        levelProgress = (player.dna / neededDNA) * 100;
        document.querySelector('.level-progress').style.width = `${levelProgress}%`;
    }
}

// Оптимизированное управление
function setupTouchControls() {
    canvas.addEventListener('touchstart', e => {
        if(touchId === null) {
            touchId = e.touches[0].identifier;
            const touch = e.touches[0];
            handleTouchStart(touch.clientX, touch.clientY);
        }
    });
    
    canvas.addEventListener('touchmove', e => {
        for(let touch of e.touches) {
            if(touch.identifier === touchId) {
                handleTouchMove(touch.clientX, touch.clientY);
            }
        }
    });
    
    canvas.addEventListener('touchend', e => {
        for(let touch of e.changedTouches) {
            if(touch.identifier === touchId) {
                touchId = null;
                joystickVector = { x: 0, y: 0 };
            }
        }
    });
}

function handleTouchStart(x, y) {
    const rect = canvas.getBoundingClientRect();
    targetX = x - rect.left;
    targetY = y - rect.top;
}

function handleTouchMove(x, y) {
    const rect = canvas.getBoundingClientRect();
    const touchX = x - rect.left;
    const touchY = y - rect.top;
    
    const dx = touchX - (canvas.width/2);
    const dy = touchY - (canvas.height/2);
    const dist = Math.sqrt(dx*dx + dy*dy);
    
    if(dist > JOYSTICK_RADIUS) {
        const angle = Math.atan2(dy, dx);
        joystickVector = {
            x: Math.cos(angle),
            y: Math.sin(angle)
        };
    } else {
        joystickVector = { x: dx/JOYSTICK_RADIUS, y: dy/JOYSTICK_RADIUS };
    }
}

// Обновленный цикл движения игрока
function updatePlayerMovement() {
    const speed = player.speed * (player.energy > 0 ? 1 : 0.5);
    
    if(joystickVector.x !== 0 || joystickVector.y !== 0) {
        player.x += joystickVector.x * speed;
        player.y += joystickVector.y * speed;
        player.direction = Math.atan2(joystickVector.y, joystickVector.x);
        player.energy = Math.max(0, player.energy - 0.1);
    }
    
    // Обновление камеры
    cameraX = player.x - canvas.width/2;
    cameraY = player.y - canvas.height/2;
}

// Остальные функции обновлены аналогичным образом...

// Инициализация
function initGame() {
    setupTouchControls();
    generateWorld();
    update();
}

// Обновленная функция сбора ресурсов
function collectResource(resource) {
    createFoodEffect(resource.x, resource.y);
    if(resource.type === 'food') {
        player.health = Math.min(100, player.health + 5);
    } else {
        player.dna += 1;
        updateLevelSystem();
    }
}

// Обновленная функция отрисовки глаз игрока
function drawPlayer() {
    // Тело
    ctx.fillStyle = '#ffffff';
    ctx.beginPath();
    ctx.arc(player.x - cameraX, player.y - cameraY, player.size, 0, Math.PI*2);
    ctx.fill();

    // Глаза
    const eyeDist = player.size * 0.4;
    const eyeAngle = player.direction;
    [Math.PI/6, -Math.PI/6].forEach(offset => {
        ctx.fillStyle = '#ffffff';
        ctx.beginPath();
        ctx.arc(
            player.x - cameraX + Math.cos(eyeAngle + offset) * eyeDist,
            player.y - cameraY + Math.sin(eyeAngle + offset) * eyeDist,
            player.size * 0.15, 0, Math.PI*2
        );
        ctx.fill();
    });
}

// Обновленная функция draw()
function draw() {
    // ... остальная отрисовка
    drawPlayer();
}

// Остальной код аналогичен предыдущей версии с интеграцией новых функций
</script>
</body>
</html>