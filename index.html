<!DOCTYPE html>
<html>
<head>
    <title>Microbe Evolution</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <style>
        body { margin: 0; overflow: hidden; touch-action: none; background: #1a1a1a; }
        #gameCanvas { position: absolute; }
        .ui {
            position: fixed; padding: 10px; background: #00000055; border-radius: 5px; 
            color: white; font-family: Arial;
        }
        #stats { top: 10px; left: 10px; }
        #abilities { bottom: 10px; right: 10px; text-align: right; }
        button { background: #444; color: white; border: none; padding: 8px; margin: 2px; border-radius: 3px; }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <div id="stats" class="ui">
        <div>Health: <span id="health">100</span></div>
        <div>Energy: <span id="energy">50</span></div>
        <div>DNA: <span id="dna">0</span></div>
    </div>
    <div id="abilities" class="ui">
        <button onclick="evolve('speed')">Speed+ (10 DNA)</button>
        <button onclick="evolve('health')">Health+ (15 DNA)</button>
        <button onclick="evolve('vision')">Vision+ (20 DNA)</button>
    </div>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const WORLD_SIZE = 2000;
let cameraX = 0, cameraY = 0;

// Настройки стайного поведения
const FLOCK_SETTINGS = {
    separationDistance: 40,
    alignmentDistance: 80,
    cohesionDistance: 100,
    separationForce: 0.05,
    alignmentForce: 0.05,
    cohesionForce: 0.05
};

// Настройки размножения
const REPRODUCTION_SETTINGS = {
    minHealth: 80,
    energyCost: 30,
    cooldown: 10000
};

function resizeCanvas() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
}
resizeCanvas();
window.addEventListener('resize', resizeCanvas);

const player = {
    x: WORLD_SIZE/2, y: WORLD_SIZE/2, size: 20,
    speed: 2, health: 100, energy: 50, dna: 0,
    vision: 200, direction: 0
};

const world = {
    resources: [],
    creatures: [],
    particles: []
};

function createCreature(type, x, y, parent) {
    const base = parent ? {
        ...parent,
        x, y,
        health: 100,
        lastReproduction: Date.now()
    } : {
        x, y, size: 15, health: 100,
        direction: 0, speed: 1.5,
        attack: 0, lastAttack: 0,
        lastReproduction: 0
    };
    
    if(!parent) {
        switch(type) {
            case 'predator':
                return {...base, 
                    color: '#ff4444', 
                    speed: 2.2,
                    attack: 5,
                    vision: 300
                };
            case 'herbivore':
                return {...base,
                    color: '#44ff44',
                    speed: 1.8,
                    flee: true
                };
            case 'parasite':
                return {...base,
                    color: '#aa44ff',
                    size: 10,
                    speed: 1.7,
                    drain: 2
                };
        }
    }
    return base;
}

function generateWorld() {
    for(let i = 0; i < 100; i++) {
        world.resources.push({
            x: Math.random() * WORLD_SIZE,
            y: Math.random() * WORLD_SIZE,
            type: Math.random() > 0.2 ? 'food' : 'dna',
            value: 10
        });
    }
    
    for(let i = 0; i < 20; i++) {
        const type = ['predator', 'herbivore', 'parasite'][Math.floor(Math.random()*3)];
        world.creatures.push(createCreature(type, 
            Math.random() * WORLD_SIZE,
            Math.random() * WORLD_SIZE
        ));
    }
}

function updateFlocking(creature) {
    if(!creature.flee) return;
    
    let separation = { x: 0, y: 0 };
    let alignment = { x: 0, y: 0 };
    let cohesion = { x: 0, y: 0 };
    let neighbors = 0;

    world.creatures.forEach(other => {
        if(other === creature || !other.flee) return;
        const dist = distance(creature, other);
        
        if(dist < FLOCK_SETTINGS.separationDistance) {
            separation.x += (creature.x - other.x)/dist;
            separation.y += (creature.y - other.y)/dist;
        }
        
        if(dist < FLOCK_SETTINGS.alignmentDistance) {
            alignment.x += Math.cos(other.direction);
            alignment.y += Math.sin(other.direction);
        }
        
        if(dist < FLOCK_SETTINGS.cohesionDistance) {
            cohesion.x += other.x;
            cohesion.y += other.y;
            neighbors++;
        }
    });

    if(neighbors > 0) {
        cohesion.x /= neighbors;
        cohesion.y /= neighbors;
        cohesion.x -= creature.x;
        cohesion.y -= creature.y;
        const dist = Math.sqrt(cohesion.x**2 + cohesion.y**2);
        if(dist > 0) {
            cohesion.x /= dist;
            cohesion.y /= dist;
        }
    }

    creature.direction += Math.atan2(
        separation.y * FLOCK_SETTINGS.separationForce +
        alignment.y * FLOCK_SETTINGS.alignmentForce +
        cohesion.y * FLOCK_SETTINGS.cohesionForce,
        separation.x * FLOCK_SETTINGS.separationForce +
        alignment.x * FLOCK_SETTINGS.alignmentForce +
        cohesion.x * FLOCK_SETTINGS.cohesionForce
    );
}

function tryReproduce(creature) {
    if(creature.health < REPRODUCTION_SETTINGS.minHealth) return;
    if(Date.now() - creature.lastReproduction < REPRODUCTION_SETTINGS.cooldown) return;
    if(Math.random() > 0.01) return;
    
    const angle = Math.random() * Math.PI * 2;
    const offspring = createCreature(null, 
        creature.x + Math.cos(angle) * 30,
        creature.y + Math.sin(angle) * 30,
        creature
    );
    
    world.creatures.push(offspring);
    creature.health -= REPRODUCTION_SETTINGS.energyCost;
    creature.lastReproduction = Date.now();
    createParticles(creature.x, creature.y, 20, '#ffff00');
}

function updateCreatures() {
    world.creatures.forEach(creature => {
        // Стайное поведение для травоядных
        if(creature.flee) {
            updateFlocking(creature);
            tryReproduce(creature);
        }

        // Логика движения...
        // (остальная часть функции остается без изменений)
    });
}

// Остальной код остается как в предыдущей версии
// (функции update, draw, createParticles, обработка ввода и т.д.)

// Измененная функция расстояния
function distance(a, b) {
    const dx = a.x - b.x;
    const dy = a.y - b.y;
    return Math.sqrt(dx*dx + dy*dy);
}

// Инициализация и остальные функции...
generateWorld();
update();
window.Telegram.WebApp.ready();

setInterval(() => {
    localStorage.setItem('gameState', JSON.stringify({
        player,
        world
    }));
}, 5000);
</script>
</body>
</html>