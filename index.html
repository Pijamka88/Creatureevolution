<!DOCTYPE html>
<html>
<head>
    <title>Microbe Evolution</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            overflow: hidden; 
            touch-action: none; 
            background: radial-gradient(circle, #1a1a2e, #16213e);
            color: white;
            font-family: 'Arial', sans-serif;
        }
        #gameCanvas { position: absolute; }
        .ui {
            position: fixed; 
            padding: 15px; 
            background: rgba(0, 0, 0, 0.7); 
            border-radius: 15px; 
            backdrop-filter: blur(5px);
            box-shadow: 0 0 15px rgba(0,0,0,0.3);
        }
        #stats { 
            top: 20px; 
            left: 20px; 
            display: grid;
            gap: 5px;
        }
        #abilities { 
            bottom: 20px; 
            right: 20px; 
            display: grid;
            gap: 8px;
        }
        button { 
            background: linear-gradient(145deg, #4e54c8, #8f94fb);
            color: white; 
            border: none; 
            padding: 10px 15px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            transition: transform 0.2s;
        }
        button:active { transform: scale(0.95); }
        #menu {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            padding: 30px;
            border-radius: 20px;
            background: rgba(0, 0, 0, 0.9);
            backdrop-filter: blur(10px);
            box-shadow: 0 0 30px rgba(255,255,255,0.1);
        }
        #gameOver { display: none; }
        .progress-bar {
            height: 5px;
            background: rgba(255,255,255,0.2);
            border-radius: 3px;
            overflow: hidden;
        }
        .progress-bar div {
            height: 100%;
            background: linear-gradient(90deg, #ff416c, #ff4b2b);
            transition: width 0.3s;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    
    <div id="stats" class="ui" style="display: none;">
        <div>Level: <span id="level">1</span></div>
        <div>Health: <span id="health">100</span></div>
        <div>Energy: <span id="energy">50</span></div>
        <div>DNA: <span id="dna">0</span></div>
        <div class="progress-bar"><div id="xp-bar" style="width: 0%"></div></div>
    </div>

    <div id="abilities" class="ui" style="display: none;">
        <button onclick="evolve('speed')">Speed+ (10 DNA)</button>
        <button onclick="evolve('health')">Health+ (15 DNA)</button>
        <button onclick="evolve('vision')">Vision+ (20 DNA)</button>
    </div>

    <div id="menu" class="ui">
        <h1 style="margin-bottom: 20px; font-size: 2.5em; background: linear-gradient(45deg, #4e54c8, #8f94fb);
                   -webkit-background-clip: text; color: transparent;">Microbe Evolution</h1>
        <button onclick="startNewGame()" style="margin: 10px; padding: 15px 25px;">New Game</button>
        <button onclick="continueGame()" id="continueBtn" style="margin: 10px; padding: 15px 25px;">Continue</button>
    </div>

    <div id="gameOver" class="ui">
        <h2 style="margin-bottom: 20px; color: #ff416c;">Game Over!</h2>
        <button onclick="showMenu()">Back to Menu</button>
    </div>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const WORLD_SIZE = 2000;
let cameraX = 0, cameraY = 0;
let gameState = 'menu';
let animationFrameId;
let touchStartTime = 0;
let touchStartX = 0;
let touchStartY = 0;

// Setup canvas
function resizeCanvas() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
}
resizeCanvas();
window.addEventListener('resize', resizeCanvas);

let player = {
    x: WORLD_SIZE/2, y: WORLD_SIZE/2, size: 20,
    speed: 2, health: 100, energy: 50, dna: 0,
    vision: 200, direction: 0,
    level: 1, xp: 0,
    mutations: [],
    maxHealth: 100
};

let world = {
    resources: [],
    creatures: [],
    particles: []
};

// Mutation system
const mutations = {
    speed: { 
        cost: 10, 
        effect: p => p.speed += 0.5,
        name: 'Swift Genes'
    },
    health: { 
        cost: 15, 
        effect: p => { p.maxHealth += 20; p.health = p.maxHealth },
        name: 'Tough Membrane'
    },
    vision: { 
        cost: 20, 
        effect: p => p.vision += 50,
        name: 'Enhanced Optics'
    },
    regeneration: {
        cost: 25,
        effect: p => p.regeneration = 0.1,
        name: 'Rapid Healing'
    }
};

function createCreature(type, x, y, parent) {
    const base = {
        x, y, size: 15, health: 100,
        direction: 0, speed: 1.5,
        attack: 0, lastAttack: 0,
        cooldown: false,
        mutations: parent ? [...parent.mutations] : []
    };
    
    // Mutation chance
    if(parent && Math.random() < 0.3) {
        const availableMutations = Object.keys(mutations)
            .filter(m => !base.mutations.includes(m));
        if(availableMutations.length > 0) {
            const mutation = availableMutations[Math.floor(Math.random()*availableMutations.length)];
            base.mutations.push(mutation);
            mutations[mutation].effect(base);
        }
    }

    switch(type) {
        case 'predator':
            return {...base, 
                color: '#ff4444', 
                speed: 1.8,
                attack: 5,
                vision: 300,
                attackCooldown: 3000
            };
        case 'herbivore':
            return {...base,
                color: '#44ff44',
                speed: 1.8,
                flee: true,
                herd: []
            };
        case 'parasite':
            return {...base,
                color: '#aa44ff',
                size: 10,
                speed: 1.7,
                drain: 2
            };
    }
}

function generateWorld() {
    world.resources = [];
    world.creatures = [];
    
    // Resources
    for(let i = 0; i < 100; i++) {
        world.resources.push({
            x: Math.random() * WORLD_SIZE,
            y: Math.random() * WORLD_SIZE,
            type: Math.random() > 0.2 ? 'food' : 'dna',
            value: 10
        });
    }
    
    // Creatures
    for(let i = 0; i < 15; i++) {
        const type = ['predator', 'herbivore', 'parasite'][Math.floor(Math.random()*3)];
        world.creatures.push(createCreature(type, 
            Math.random() * WORLD_SIZE,
            Math.random() * WORLD_SIZE
        ));
    }
}

function updateCreatures() {
    world.creatures.forEach((creature, index) => {
        // Herd behavior for herbivores
        if(creature.herd) {
            creature.herd = world.creatures
                .filter(c => c !== creature && c.herd)
                .filter(c => distance(c, creature) < 100)
                .slice(0, 3);
        }

        // Movement logic
        let target = null;
        if(creature.attack) { // Predator
            if(!creature.cooldown) {
                const dx = player.x - creature.x;
                const dy = player.y - creature.y;
                if(Math.sqrt(dx*dx + dy*dy) < creature.vision) {
                    target = player;
                }
            }
        } else if(creature.flee) { // Herbivore
            // Flee from predators and follow herd
            const predator = world.creatures.find(c => c.attack && distance(c, creature) < 200);
            if(predator) {
                target = predator;
            } else if(creature.herd.length > 0) {
                const avgX = creature.herd.reduce((sum, c) => sum + c.x, 0) / creature.herd.length;
                const avgY = creature.herd.reduce((sum, c) => sum + c.y, 0) / creature.herd.length;
                creature.direction = Math.atan2(avgY - creature.y, avgX - creature.x);
            }
        } else if(creature.drain) { // Parasite
            const closest = world.creatures.concat([player])
                .reduce((closest, curr) => 
                    distance(curr, creature) < distance(closest, creature) ? curr : closest);
            if(distance(closest, creature) < 500) target = closest;
        }

        // Move
        if(target) {
            const angle = Math.atan2(target.y - creature.y, target.x - creature.x);
            creature.direction = creature.flee ? angle + Math.PI : angle;
            
            creature.x += Math.cos(creature.direction) * creature.speed;
            creature.y += Math.sin(creature.direction) * creature.speed;
        } else {
            creature.direction += (Math.random()-0.5)*0.5;
            creature.x += Math.cos(creature.direction) * creature.speed;
            creature.y += Math.sin(creature.direction) * creature.speed;
        }

        // Boundaries
        creature.x = Math.max(0, Math.min(WORLD_SIZE, creature.x));
        creature.y = Math.max(0, Math.min(WORLD_SIZE, creature.y));

        // Combat
        if(creature.attack && Date.now() - creature.lastAttack > creature.attackCooldown) {
            if(distance(creature, player) < creature.size + player.size) {
                player.health -= creature.attack;
                creature.lastAttack = Date.now();
                creature.cooldown = true;
                setTimeout(() => creature.cooldown = false, 1000);
                createParticles(player.x, player.y, 10, '#ff0000');
            }
        }
        
        // Reproduction
        if(creature.health > 150 && Math.random() < 0.002) {
            creature.health -= 50;
            world.creatures.push(createCreature(
                creature.flee ? 'herbivore' : 
                creature.attack ? 'predator' : 'parasite',
                creature.x + Math.random()*20 -10,
                creature.y + Math.random()*20 -10,
                creature
            ));
        }
    });
}

function createParticles(x, y, count, color) {
    for(let i = 0; i < count; i++) {
        world.particles.push({
            x, y,
            vx: (Math.random()-0.5)*4,
            vy: (Math.random()-0.5)*4,
            life: 1,
            color,
            size: 2 + Math.random()*3
        });
    }
}

function update() {
    if(gameState !== 'playing') return;
    
    // Player movement
    const speed = player.speed * (player.energy > 0 ? 1 : 0.5);
    if(targetX !== null && targetY !== null) {
        const dx = (targetX - canvas.width/2) - cameraX;
        const dy = (targetY - canvas.height/2) - cameraY;
        const dist = Math.sqrt(dx*dx + dy*dy);
        
        if(dist > speed) {
            player.x += (dx/dist)*speed;
            player.y += (dy/dist)*speed;
            player.direction = Math.atan2(dy, dx);
            player.energy = Math.max(0, player.energy - 0.1);
        }
    }
    
    cameraX = player.x - canvas.width/2;
    cameraY = player.y - canvas.height/2;

    // Resource collection
    world.resources = world.resources.filter(resource => {
        if(distance(resource, player) < player.size) {
            createParticles(resource.x, resource.y, 5, resource.type === 'food' ? '#00ff00' : '#00ffff');
            if(resource.type === 'food') {
                player.health = Math.min(player.maxHealth, player.health + 5);
                player.energy = Math.min(100, player.energy + 2);
            } else {
                player.dna += 1;
            }
            gainXP(5);
            return false;
        }
        return true;
    });

    updateCreatures();
    
    // Update particles
    world.particles.forEach(p => {
        p.x += p.vx;
        p.y += p.vy;
        p.life -= 0.02;
    });
    world.particles = world.particles.filter(p => p.life > 0);

    // Regeneration
    if(player.regeneration) {
        player.health = Math.min(player.maxHealth, player.health + player.regeneration);
    }

    // Update UI
    document.getElementById('health').textContent = Math.round(player.health);
    document.getElementById('energy').textContent = Math.round(player.energy);
    document.getElementById('dna').textContent = player.dna;
    document.getElementById('level').textContent = player.level;

    // Game Over check
    if(player.health <= 0) {
        gameOver();
        return;
    }

    animationFrameId = requestAnimationFrame(update);
    draw();
}

function draw() {
    ctx.fillStyle = '#1a1a2e';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // Draw resources
    world.resources.forEach(resource => {
        const screenX = resource.x - cameraX;
        const screenY = resource.y - cameraY;
        
        // Glow effect
        ctx.beginPath();
        ctx.arc(screenX, screenY, 10, 0, Math.PI*2);
        const gradient = ctx.createRadialGradient(
            screenX, screenY, 0, 
            screenX, screenY, 10
        );
        gradient.addColorStop(0, resource.type === 'food' ? '#00ff0088' : '#00ffff88');
        gradient.addColorStop(1, 'transparent');
        ctx.fillStyle = gradient;
        ctx.fill();
        
        // Core
        ctx.fillStyle = resource.type === 'food' ? '#00ff00' : '#00ffff';
        ctx.beginPath();
        ctx.arc(screenX, screenY, 5, 0, Math.PI*2);
        ctx.fill();
    });

    // Draw creatures
    world.creatures.concat([player]).forEach(creature => {
        const screenX = creature.x - cameraX;
        const screenY = creature.y - cameraY;
        
        // Body glow
        ctx.beginPath();
        ctx.arc(screenX, screenY, creature.size + 2, 0, Math.PI*2);
        const glowGradient = ctx.createRadialGradient(
            screenX, screenY, 0, 
            screenX, screenY, creature.size + 2
        );
        glowGradient.addColorStop(0, `${creature.color}88`);
        glowGradient.addColorStop(1, 'transparent');
        ctx.fillStyle = glowGradient;
        ctx.fill();
        
        // Body
        ctx.fillStyle = creature.color || '#ffffff';
        ctx.beginPath();
        ctx.arc(screenX, screenY, creature.size, 0, Math.PI*2);
        ctx.fill();

        // Eyes with glow
        const eyeDist = creature.size * 0.4;
        const eyeAngle = creature.direction;
        [Math.PI/6, -Math.PI/6].forEach(offset => {
            const eyeX = screenX + Math.cos(eyeAngle + offset) * eyeDist;
            const eyeY = screenY + Math.sin(eyeAngle + offset) * eyeDist;
            
            // Eye glow
            ctx.beginPath();
            ctx.arc(eyeX, eyeY, creature.size * 0.25, 0, Math.PI*2);
            ctx.fillStyle = 'rgba(255,255,255,0.3)';
            ctx.fill();
            
            // Eye
            ctx.beginPath();
            ctx.arc(eyeX, eyeY, creature.size * 0.15, 0, Math.PI*2);
            ctx.fillStyle = '#ffffff';
            ctx.fill();
        });
    });

    // Draw particles
    world.particles.forEach(p => {
        ctx.fillStyle = p.color;
        ctx.globalAlpha = p.life;
        ctx.beginPath();
        ctx.arc(p.x - cameraX, p.y - cameraY, p.size, 0, Math.PI*2);
        ctx.fill();
        
        if(p.color === '#00ff00') {
            ctx.strokeStyle = p.color;
            ctx.lineWidth = 0.5;
            ctx.beginPath();
            ctx.arc(p.x - cameraX, p.y - cameraY, p.size * 2, 0, Math.PI*2);
            ctx.stroke();
        }
    });
    ctx.globalAlpha = 1;
}

function distance(a, b) {
    return Math.sqrt((a.x - b.x)**2 + (a.y - b.y)**2);
}

function gainXP(amount) {
    player.xp += amount;
    const xpNeeded = player.level * 50;
    if(player.xp >= xpNeeded) {
        player.level++;
        player.xp = 0;
        player.dna += 5;
        player.health = player.maxHealth;
        createParticles(player.x, player.y, 20, '#ffffff');
    }
    updateXPBar();
}

function updateXPBar() {
    const xpNeeded = player.level * 50;
    const percent = (player.xp / xpNeeded) * 100;
    document.getElementById('xp-bar').style.width = `${percent}%`;
}

function evolve(type) {
    const upgrade = mutations[type];
    if(player.dna >= upgrade.cost) {
        upgrade.effect(player);
        player.dna -= upgrade.cost;
        player.mutations.push(type);
    }
}

// Game state management
function startNewGame() {
    gameState = 'playing';
    document.getElementById('menu').style.display = 'none';
    document.getElementById('stats').style.display = 'grid';
    document.getElementById('abilities').style.display = 'grid';
    document.getElementById('gameOver').style.display = 'none';
    
    player = {
        x: WORLD_SIZE/2, y: WORLD_SIZE/2, size: 20,
        speed: 2, health: 100, energy: 50, dna: 0,
        vision: 200, direction: 0,
        level: 1, xp: 0,
        mutations: [],
        maxHealth: 100
    };
    
    generateWorld();
    update();
}

function continueGame() {
    const saved = localStorage.getItem('gameState');
    if(saved) {
        const state = JSON.parse(saved);
        Object.assign(player, state.player);
        Object.assign(world, state.world);
        gameState = 'playing';
        document.getElementById('menu').style.display = 'none';
        document.getElementById('stats').style.display = 'grid';
        document.getElementById('abilities').style.display = 'grid';
        update();
    }
}

function gameOver() {
    gameState = 'gameOver';
    cancelAnimationFrame(animationFrameId);
    document.getElementById('stats').style.display = 'none';
    document.getElementById('abilities').style.display = 'none';
    document.getElementById('gameOver').style.display = 'block';
}

function showMenu() {
    gameState = 'menu';
    document.getElementById('menu').style.display = 'block';
    document.getElementById('gameOver').style.display = 'none';
    document.getElementById('continueBtn').style.display = 
        localStorage.getItem('gameState') ? 'inline-block' : 'none';
}

// Auto-save
setInterval(() => {
    if(gameState === 'playing') {
        localStorage.setItem('gameState', JSON.stringify({
            player,
            world
        }));
    }
}, 5000);

// Mobile controls
canvas.addEventListener('touchstart', e => {
    e.preventDefault();
    const touch = e.touches[0];
    touchStartTime = Date.now();
    touchStartX = touch.clientX;
    touchStartY = touch.clientY;
});

canvas.addEventListener('touchmove', e => {
    e.preventDefault();
    const touch = e.touches[0];
    targetX = touch.clientX;
    targetY = touch.clientY;
});

canvas.addEventListener('touchend', e => {
    const touchDuration = Date.now() - touchStartTime;
    if(touchDuration < 200) {
        const touch = e.changedTouches[0];
        targetX = touch.clientX;
        targetY = touch.clientY;
    }
});

// Init
showMenu();
window.Telegram.WebApp.ready();
</script>
</body>
</html>